Короткий ответ: **сначала “исчезающие плашки”**, потом **теги/пресеты + автотеги/чистка**, и уже после — **GitHub-интеграция**.

Почему так:

1. **Исчезающие плашки (modal) — минимальный риск, максимум пользы.**
   Это чистый UX-фикс, трогает только вывод меню. Сразу перестаёт плодиться мусор в чате, работать приятнее. Мы уже дали точные патчи (`last_panel_msg_id` + `show_panel()`), применяешь миграцию и готово.

2. **Теги и порядок (пресеты, автотег по дате, .pmignore, cleanup по дате) — опора для порядка.**

   * Пресеты/кнопки → меньше думать, быстрее метить артефакты.
   * Автотег `rel-YYYY-MM-DD` при любом импорте → видно “что новое”, легко чистить.
   * `.pmignore` → не зальём в память мусор (`node_modules`, картинки и т. п.).
   * `Cleanup by date` → быстро разгребать “хвосты”.
     Это улучшает качество данных и масштабируемость.

3. **GitHub (Repo add/list/sync) — последним.**
   Это функционал с наибольшим “радиусом поражения”: git в контейнере, токены/права, сеть, приватные репы. Когда UI/теги стабильны, подключать репозитории безопаснее. Стартуй с публичного репо, затем добавь `GITHUB_TOKEN` (fine-grained, read-only).

---

## Предлагаемый план действий (очень конкретно)

1. **Поставить модальные плашки**

   * Применить миграцию `0007_last_panel_msg`.
   * Залить `app/ui.py` и заменить вызовы на `show_panel(...)` в Actions/Projects/Sources/Scope/Export/Repo/Cleanup.
   * `alembic upgrade head` → `linkbot` перезапуск.
   * Проверка: открыть “Projects”, затем “Scope” — предыдущая панель исчезает.

2. **Довести теги и порядок**

   * Включить **Tag-плашку** (пресеты + свободный ввод) и фикс ForceReply (мы дали хендлеры).
   * Включить **автотег даты** при импортe (`rel-YYYY-MM-DD`).
   * Подключить **.pmignore** для ZIP (и можно использовать и при репо-синхе).
   * Включить **Cleanup by date** (кнопка в Actions).
   * Проверка: импортируй ZIP → в `/memory list` видно тег даты; нажми “Cleanup” и удали по дате.

3. **Экспорт**

   * “Export project / Export context” — убедись, что показывает активный проект, отдаёт ZIP (есть защита от отсутствия проекта).
   * Быстро проверить: экспорт контекста с фильтром `tags=summary` — получишь компактный отчёт.

4. **GitHub**

   * Убедись, что образ бота содержит `git`, есть volume `/app/repos`.
   * Кнопки **Repo → Add/List/Sync/Remove**.
   * Для приватных: добавить в `.env` `GITHUB_TOKEN` (fine-grained, только read access к нужному репо).
   * Проверка: `Repo → Add`, затем `Sync` (покажет лог `git`), после — импорт через ZIP/синк-индексацию по diff (если захотим расширить).

---

## Бонус: безопасные “рубильники”

Если хочешь включать/выключать крупные блоки на время тестов — добавь флаги в `.env`:

```
ENABLE_REPO=true
ENABLE_EXPORT=true
ENABLE_CLEANUP=true
```

И в коде просто не показывай соответствующие кнопки, если флаг `false`. Это снижает риск, когда отлаживаешь частями.

---

супер идея — «плашки» должны вести себя как модальные: открылась новая → старая исчезла. Делаем это аккуратно и без побочек.

Ниже — минимальные точные правки: одна новая колонка для хранения id последней «панели», утилита `show_panel()` и замены в хендлерах «Projects / Sources / Scope / Export / Repo / Cleanup / Actions». Вставь 1-в-1 и запусти миграцию.

---

# 1) Alembic: запомним «последнюю панель»

**`alembic/versions/0007_last_panel_msg.py`**

```python
from alembic import op
import sqlalchemy as sa

revision = "0007_last_panel_msg"
down_revision = "0006_tag_presets"  # поправь если номер другой
branch_labels = None
depends_on = None

def upgrade():
    op.add_column("user_state", sa.Column("last_panel_msg_id", sa.Integer(), nullable=True))

def downgrade():
    op.drop_column("user_state", "last_panel_msg_id")
```

---

# 2) Модель

**`app/models.py`**

```diff
 class UserState(Base):
     __tablename__ = "user_state"
     user_id: Mapped[int] = mapped_column(BigInteger, primary_key=True)
     active_project_id: Mapped[int | None] = mapped_column(ForeignKey("projects.id", ondelete="SET NULL"), nullable=True)
     preferred_model: Mapped[str] = mapped_column(String(32), default="gpt-5")
     chat_mode: Mapped[bool] = mapped_column(Boolean, default=False)
     quiet_mode: Mapped[bool] = mapped_column(Boolean, default=False)
     sources_mode: Mapped[str] = mapped_column(String(16), default="active")
     scope_mode: Mapped[str] = mapped_column(String(16), default="auto")
     context_kinds: Mapped[str | None] = mapped_column(String(256))
     context_tags: Mapped[str | None] = mapped_column(String(256))
     created_at: Mapped[DateTime] = mapped_column(DateTime(timezone=True), server_default=func.now())
+    last_panel_msg_id: Mapped[int | None] = mapped_column(Integer, nullable=True)
```

---

# 3) Утилита «модальной» панели

**`app/ui.py`** (новый файл)

```python
from __future__ import annotations
from aiogram import Bot
from aiogram.types import InlineKeyboardMarkup
from sqlalchemy.ext.asyncio import AsyncSession
from app.services.memory import _ensure_user_state

async def show_panel(st: AsyncSession, bot: Bot, chat_id: int, user_id: int, text: str, kb: InlineKeyboardMarkup):
    """
    Удаляет предыдущую «панель» пользователя и присылает новую.
    Возвращает объект Message (aiogram).
    """
    stt = await _ensure_user_state(st, user_id)
    old_id = stt.last_panel_msg_id
    if old_id:
        try:
            await bot.delete_message(chat_id, old_id)
        except Exception:
            # мог быть уже удалён/очищен — игнорируем
            pass

    sent = await bot.send_message(chat_id, text, reply_markup=kb)
    stt.last_panel_msg_id = sent.message_id
    await st.flush()
    return sent
```

---

# 4) Меняем все «панели» на show\_panel()

## 4.1 Actions (главная панель)

**`app/handlers/keyboard.py`** (кнопка ⚙️ Actions)

```diff
 @router.message(F.text == BTN_ACTIONS)
 async def kb_actions(message: Message):
-    from app.handlers.menu import kb_menu  # импорт внутри, чтобы не ловить циклы
-    from app.services.memory import get_preferred_model
-    st = await anext(session)
-    model = await get_preferred_model(st, message.from_user.id)
-    await message.answer("Панель действий:", reply_markup=kb_menu(model))
+    from app.handlers.menu import kb_menu
+    from app.db import session_scope
+    from app.services.memory import get_preferred_model
+    from app.ui import show_panel
+    async with session_scope() as st:
+        model = await get_preferred_model(st, message.from_user.id)
+        await show_panel(st, message.bot, message.chat.id, message.from_user.id,
+                         "Панель действий:", kb_menu(model))
```

*(если у тебя Actions вызывается как `/actions` — аналогично там.)*

## 4.2 Sources / Scope (кнопочные плашки)

**`app/handlers/menu.py`**

```diff
 from app.db import session_scope
+from app.ui import show_panel
@@
 @router.callback_query(F.data == "sources:toggle")
 async def sources_toggle(cb: CallbackQuery):
     async with session_scope() as st:
         from app.services.memory import get_chat_flags
         _, _, current, _ = await get_chat_flags(st, cb.from_user.id)
-    kb = build_sources_kb(current)
-    await cb.message.answer("Выбери источники (Sources):", reply_markup=kb)
+        kb = build_sources_kb(current)
+        await show_panel(st, cb.message.bot, cb.message.chat.id, cb.from_user.id,
+                         "Выбери источники (Sources):", kb)
     await cb.answer()
@@
 @router.callback_query(F.data == "scope:toggle")
 async def scope_toggle(cb: CallbackQuery):
     async with session_scope() as st:
         _, _, _, current = await get_chat_flags(st, cb.from_user.id)
-    kb = build_scope_kb(current)
-    await cb.message.answer("Выбери область ответа (Scope):", reply_markup=kb)
+        kb = build_scope_kb(current)
+        await show_panel(st, cb.message.bot, cb.message.chat.id, cb.from_user.id,
+                         "Выбери область ответа (Scope):", kb)
     await cb.answer()
```

*(обработчики `sources:set:*` / `scope:set:*` можно оставить как есть — они коротко подтверждают и чат не захламляют.)*

## 4.3 Projects

```diff
 @router.callback_query(F.data.startswith("projects:list"))
 async def projects_list(cb: CallbackQuery):
     async with session_scope() as st:
         allp = await list_projects(st)
         linked = set(await get_linked_project_ids(st, cb.from_user.id))
         cur = await get_active_project(st, cb.from_user.id)
-        kb = build_projects_page(allp, linked, cur.id if cur else None)
-    await cb.message.answer("Проекты:", reply_markup=kb)
+        kb = build_projects_page(allp, linked, cur.id if cur else None)
+        await show_panel(st, cb.message.bot, cb.message.chat.id, cb.from_user.id,
+                         "Проекты:", kb)
     await cb.answer()
```

*(обработчики `projects:link:*` и `projects:activate:*` оставь с `edit_reply_markup` — они обновляют ту же плашку.)*

## 4.4 Export / Repo / Cleanup

**`app/handlers/export.py`**

```diff
 from app.db import session_scope
+from app.ui import show_panel
@@
 @router.callback_query(F.data == "export:open")
 async def export_open(cb: CallbackQuery):
     async with session_scope() as st:
         proj = await get_active_project(st, cb.from_user.id)
         if not proj:
             await cb.message.answer("Сначала выбери проект: Actions → Projects.")
             return await cb.answer()
         kb = build_export_kb(proj.name)
-    await cb.message.answer("Экспорт:", reply_markup=kb)
+        await show_panel(st, cb.message.bot, cb.message.chat.id, cb.from_user.id,
+                         "Экспорт:", kb)
     await cb.answer()
```

**`app/handlers/repo.py`**

```diff
 from app.db import session_scope
+from app.ui import show_panel
@@
 @router.callback_query(F.data == "repo:open")
 async def repo_open(cb: CallbackQuery):
-    await cb.message.answer("Repo:", reply_markup=repo_menu_kb()); await cb.answer()
+    async with session_scope() as st:
+        await show_panel(st, cb.message.bot, cb.message.chat.id, cb.from_user.id,
+                         "Repo:", repo_menu_kb())
+    await cb.answer()
```

**`app/handlers/cleanup.py`**

```diff
 from app.db import session_scope
+from app.ui import show_panel
@@
 @router.callback_query(F.data == "cleanup:open")
 async def cleanup_open(cb: CallbackQuery):
-    await cb.message.answer(
-        "Удалить артефакты ПО ДАТЕ.\n"
-        "Введи дату в формате YYYY-MM-DD (удалим с этой даты и позже).",
-        reply_markup=ForceReply(selective=True)
-    )
+    async with session_scope() as st:
+        await show_panel(
+            st, cb.message.bot, cb.message.chat.id, cb.from_user.id,
+            "Удалить артефакты ПО ДАТЕ.\n"
+            "Введи дату в формате YYYY-MM-DD (удалим с этой даты и позже).",
+            None
+        )
+    await cb.message.answer("Ответь этой датой в реплае к предыдущему сообщению.", reply_markup=ForceReply(selective=True))
     await cb.answer()
```

*(тут мы храним «панельное» сообщение, а ForceReply — отдельное временное.)*

---

# 5) Миграция и перезапуск

```powershell
docker compose --env-file .env run --rm bot alembic upgrade head
linkbot
```

---

## Как теперь работает

* Нажал «Projects» → появилась плашка «Проекты».
* Нажал «Scope» → **предыдущая плашка удалена**, показывается «Scope».
* Любая «панельная» кнопка (Actions / Projects / Sources / Scope / Export / Repo / Cleanup) всегда **очищает** предыдущую панель у данного пользователя, чтобы чат не разрастался.

Если где-то увидишь старую плашку, которую не стирает (например, в редко используемом хендлере) — скажи название кнопки, добавлю `show_panel` туда же.

Делаем «антидурак» и доводим до рабочего UX: Export с явным проектом, Repo как плашка с кнопками + git-sync, .pmignore, автотег даты (`rel-YYYY-MM-DD`) на импорт, «чистка по дате», пагинация проектов, пресеты тегов + свободный ввод, и выбор **Scope** кнопками.

Ниже — готовые минимальные патчи. Вставляй 1-в-1 и перезапускай `linkbot`.

---

# 0) Зависимости и Docker

**`requirements.txt`**

```
pathspec>=0.12.1   # .pmignore
```

**`Dockerfile`** (или `bot`-image): добавь git

```dockerfile
RUN apt-get update && apt-get install -y git && rm -rf /var/lib/apt/lists/*
```

**`.env`**

```
GITHUB_TOKEN=ghp_xxx   # если нужны приватные репозитории (optional)
```

**`docker-compose.yml`** — том под репозитории

```yaml
services:
  bot:
    volumes:
      - repos_data:/app/repos   # локальный кэш git
volumes:
  repos_data:
```

---

# 1) .pmignore: фильтрация шумовых файлов

**`app/ignore.py`** (новый)

```python
from __future__ import annotations
from pathlib import Path
from typing import Iterable
from pathspec import PathSpec

DEFAULT_PMIGNORE = """
# папки
node_modules/
dist/
build/
.cache/
.venv/
venv/
.git/
__pycache__/
# файлы
*.png
*.jpg
*.jpeg
*.gif
*.webp
*.mp4
*.pdf
*.zip
*.tar
*.log
"""

def load_pmignore(root: Path, extra_patterns: Iterable[str] | None = None) -> PathSpec:
    patts: list[str] = []
    pm = root / ".pmignore"
    if pm.exists():
        patts += pm.read_text(encoding="utf-8", errors="ignore").splitlines()
    else:
        patts += DEFAULT_PMIGNORE.splitlines()
    if extra_patterns:
        patts += list(extra_patterns)
    return PathSpec.from_lines("gitwildmatch", patts)

def iter_text_files(root: Path, spec: PathSpec):
    for p in root.rglob("*"):
        if p.is_file():
            rel = p.relative_to(root).as_posix()
            if spec.match_file(rel):
                continue
            # простая эвристика «текст/нет»
            try:
                data = p.read_bytes()
                data.decode("utf-8")
            except Exception:
                continue
            yield rel, data.decode("utf-8", errors="ignore")
```

---

# 2) Импорт: автотег даты `rel-YYYY-MM-DD`

**`app/handlers/import_file.py`** — добавим автотег и .pmignore для ZIP

```diff
 from datetime import datetime
+from pathlib import Path
+from app.ignore import load_pmignore, iter_text_files

 @router.message(Command("import"), F.reply_to_message)
 async def import_document(...):
     ...
-    await create_import(st, proj, title=title, text=text, chunk_size=settings.chunk_size, overlap=settings.chunk_overlap)
+    date_tag = f"rel-{datetime.utcnow().date().isoformat()}"
+    await create_import(st, proj, title=title, text=text,
+                        chunk_size=settings.chunk_size, overlap=settings.chunk_overlap,
+                        tags=[date_tag])  # автотег даты
     await st.commit()
     ...

 # ZIP импорт (если у тебя отдельный хендлер — дополни его так)
 @router.message(Command("importzip"), F.reply_to_message)
 async def import_zip(message: Message, ...):
     ...
     # сохранили zip в MinIO → data = байты архива
     tmp = Path("/tmp/pm_zip")
     if tmp.exists():
         import shutil; shutil.rmtree(tmp)
     tmp.mkdir(parents=True, exist_ok=True)

     # распаковать
     import zipfile, io
     with zipfile.ZipFile(io.BytesIO(data)) as z:
         z.extractall(tmp)

     spec = load_pmignore(tmp)
     date_tag = f"rel-{datetime.utcnow().date().isoformat()}"
     imported = 0
     for rel, text in iter_text_files(tmp, spec):
         title = f"{doc.file_name}:{rel}"
         await create_import(st, proj, title=title, text=text,
                             chunk_size=settings.chunk_size, overlap=settings.chunk_overlap,
                             tags=[date_tag])
         imported += 1
     await st.commit()
     await message.answer(f"Импорт ZIP завершён: {imported} файлов.\nТег: <code>{date_tag}</code>")
```

> Теперь любой импорт (txt/md/json и из ZIP) помечается тегом вида `rel-2025-09-13`. Это упрощает фильтрацию и «чистки».

---

# 3) Чистка по дате (удалить всё «с такой-то даты»)

**`app/handlers/cleanup.py`** (новый)

```python
from __future__ import annotations
import re, datetime as dt
from aiogram import Router, F
from aiogram.types import CallbackQuery, Message, ForceReply, InlineKeyboardMarkup, InlineKeyboardButton
import sqlalchemy as sa
from sqlalchemy.ext.asyncio import AsyncSession
from app.db import session_scope
from app.services.memory import get_active_project
from app.models import Artifact

router = Router()

@router.callback_query(F.data == "cleanup:open")
async def cleanup_open(cb: CallbackQuery):
    await cb.message.answer(
        "Удалить артефакты ПО ДАТЕ.\n"
        "Введи дату в формате YYYY-MM-DD (удалим с этой даты и позже).",
        reply_markup=ForceReply(selective=True)
    )
    await cb.answer()

@router.message(F.reply_to_message & F.reply_to_message.text.startswith("Удалить артефакты ПО ДАТЕ"))
async def cleanup_reply(message: Message):
    m = re.search(r"(\d{4}-\d{2}-\d{2})", message.text or "")
    if not m:
        return await message.answer("Формат неверный. Пример: 2025-09-13")
    try:
        d0 = dt.date.fromisoformat(m.group(1))
    except:
        return await message.answer("Дата неверная.")
    async with session_scope() as st:
        proj = await get_active_project(st, message.from_user.id)
        if not proj:
            return await message.answer("Сначала выбери проект (Actions → Projects).")
        # удалим всё по created_at >= d0 или имеющее тег rel-d0/позже — выберем по дате создания:
        q = sa.delete(Artifact).where(
            Artifact.project_id == proj.id,
            Artifact.created_at >= dt.datetime.combine(d0, dt.time.min)
        )
        res = await st.execute(q); await st.commit()
    await message.answer(f"🧹 Удалено артефактов: {res.rowcount or 0}")
```

В **Actions** добавим кнопку «🧹 Cleanup» → `cleanup:open` (см. п.6).

---

# 4) Export: «защита от дурака» + варианты

**`app/exporter.py`** (новый)

````python
from __future__ import annotations
import io, zipfile, datetime as dt
from typing import Iterable
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_
from app.models import Artifact, Project

async def export_project_zip(st: AsyncSession, project: Project, kinds: list[str] | None = None, tags: list[str] | None = None) -> bytes:
    buf = io.BytesIO()
    with zipfile.ZipFile(buf, "w", zipfile.ZIP_DEFLATED) as z:
        # markdown-dамп всего
        md = ["# Export", f"Project: {project.name}", f"Date: {dt.datetime.utcnow().isoformat()}Z", ""]
        q = select(Artifact).where(Artifact.project_id == project.id).order_by(Artifact.created_at.asc())
        if kinds:
            q = q.where(Artifact.kind.in_(kinds))
        res = await st.execute(q)
        for a in res.scalars():
            md.append(f"## [{a.kind}] {a.title}  \n<small>{a.created_at}</small>\n\n```\n{a.raw_text}\n```")
        z.writestr("EXPORT.md", "\n".join(md))
    buf.seek(0)
    return buf.getvalue()
````

**`app/handlers/export.py`** (новый)

```python
from __future__ import annotations
from aiogram import Router, F
from aiogram.types import CallbackQuery, InlineKeyboardMarkup, InlineKeyboardButton, FSInputFile
from app.db import session_scope
from app.services.memory import get_active_project, get_context_filters_state
from app.exporter import export_project_zip

router = Router()

def build_export_kb(project_name: str) -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(inline_keyboard=[[
        InlineKeyboardButton(text=f"📦 Export project ({project_name})", callback_data="export:project"),
        InlineKeyboardButton(text="🎯 Export context (filters)", callback_data="export:context"),
    ]])

@router.callback_query(F.data == "export:open")
async def export_open(cb: CallbackQuery):
    async with session_scope() as st:
        proj = await get_active_project(st, cb.from_user.id)
        if not proj:
            await cb.message.answer("Сначала выбери проект: Actions → Projects.")
            return await cb.answer()
        kb = build_export_kb(proj.name)
    await cb.message.answer("Экспорт:", reply_markup=kb)
    await cb.answer()

@router.callback_query(F.data == "export:project")
async def export_project(cb: CallbackQuery):
    async with session_scope() as st:
        proj = await get_active_project(st, cb.from_user.id)
        if not proj:
            await cb.message.answer("Нет активного проекта.")
            return await cb.answer()
        data = await export_project_zip(st, proj)
    path = "/tmp/pm_export.zip"
    with open(path, "wb") as f: f.write(data)
    await cb.message.answer_document(FSInputFile(path, filename=f"{proj.name}-export.zip"), caption=f"Export: {proj.name}")
    await cb.answer()

@router.callback_query(F.data == "export:context")
async def export_context(cb: CallbackQuery):
    async with session_scope() as st:
        proj = await get_active_project(st, cb.from_user.id)
        if not proj:
            await cb.message.answer("Нет активного проекта.")
            return await cb.answer()
        kinds, tags = await get_context_filters_state(st, cb.from_user.id)
        data = await export_project_zip(st, proj, kinds=kinds or None, tags=tags or None)
    path = "/tmp/pm_ctx_export.zip"
    with open(path, "wb") as f: f.write(data)
    await cb.message.answer_document(FSInputFile(path, filename=f"{proj.name}-context.zip"), caption=f"Export (filters): {proj.name}")
    await cb.answer()
```

---

# 5) Repo: add/list/sync/remove (git-sync по кнопке)

**БД: миграция** `alembic/versions/0005_repos.py`

```python
from alembic import op
import sqlalchemy as sa

revision = "0005_repos"
down_revision = "0004_nullable_project_in_bot_messages"

def upgrade():
    op.create_table("repos",
        sa.Column("id", sa.Integer(), primary_key=True),
        sa.Column("user_id", sa.BigInteger(), nullable=False),
        sa.Column("alias", sa.String(64), nullable=False),
        sa.Column("url", sa.String(512), nullable=False),
        sa.Column("branch", sa.String(64), nullable=False, server_default="main"),
        sa.Column("last_synced_at", sa.DateTime(timezone=True), nullable=True),
        sa.UniqueConstraint("user_id","alias", name="uq_user_repo_alias")
    )

def downgrade():
    op.drop_table("repos")
```

**`app/models.py`** (добавь модель)

```python
class Repo(Base):
    __tablename__ = "repos"
    id: Mapped[int] = mapped_column(primary_key=True)
    user_id: Mapped[int] = mapped_column(BigInteger)
    alias: Mapped[str] = mapped_column(String(64))
    url: Mapped[str] = mapped_column(String(512))
    branch: Mapped[str] = mapped_column(String(64), default="main")
    last_synced_at: Mapped[DateTime | None] = mapped_column(DateTime(timezone=True))
```

**`app/repo.py`** (новый — git CLI)

```python
from __future__ import annotations
import subprocess, os, shlex, datetime as dt
from pathlib import Path
from typing import Optional
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, delete
from app.models import Repo

BASE = Path("/app/repos")

def _runcmd(cmd: str, cwd: Optional[Path] = None) -> tuple[int, str]:
    p = subprocess.Popen(shlex.split(cmd), cwd=str(cwd) if cwd else None,
                         stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
    out, _ = p.communicate()
    return p.returncode, out

async def repo_add(st: AsyncSession, user_id: int, alias: str, url: str, branch: str = "main"):
    r = Repo(user_id=user_id, alias=alias, url=url, branch=branch)
    st.add(r); await st.flush(); return r

async def repo_list(st: AsyncSession, user_id: int):
    res = await st.execute(select(Repo).where(Repo.user_id==user_id).order_by(Repo.alias.asc()))
    return list(res.scalars())

async def repo_remove(st: AsyncSession, user_id: int, alias: str):
    await st.execute(delete(Repo).where(Repo.user_id==user_id, Repo.alias==alias))

async def repo_sync(st: AsyncSession, user_id: int, alias: str, token: str | None = None) -> str:
    r = (await st.execute(select(Repo).where(Repo.user_id==user_id, Repo.alias==alias))).scalars().first()
    if not r: return "Repo not found."
    BASE.mkdir(parents=True, exist_ok=True)
    path = BASE / alias
    # URL с токеном для приватных реп
    url = r.url
    if token and url.startswith("https://github.com/"):
        url = url.replace("https://", f"https://{token}@", 1)

    if not path.exists():
        code, out = _runcmd(f"git clone --depth=1 --branch {r.branch} {shlex.quote(url)} {shlex.quote(str(path))}")
    else:
        code, out = _runcmd("git fetch --all", cwd=path)
        if code==0:
            code, out2 = _runcmd(f"git reset --hard origin/{r.branch}", cwd=path)
            out += "\n" + out2
    if code==0:
        r.last_synced_at = dt.datetime.utcnow()
    await st.flush()
    return out
```

**UI: `app/handlers/repo.py`** (новый)

```python
from __future__ import annotations
from aiogram import Router, F
from aiogram.types import CallbackQuery, InlineKeyboardMarkup, InlineKeyboardButton, ForceReply, Message
from app.db import session_scope
from app.repo import repo_add, repo_list, repo_sync, repo_remove
from app.config import settings

router = Router()

def repo_menu_kb():
    return InlineKeyboardMarkup(inline_keyboard=[[
        InlineKeyboardButton(text="➕ Add", callback_data="repo:add"),
        InlineKeyboardButton(text="📜 List", callback_data="repo:list"),
    ]])

@router.callback_query(F.data == "repo:open")
async def repo_open(cb: CallbackQuery):
    await cb.message.answer("Repo:", reply_markup=repo_menu_kb()); await cb.answer()

@router.callback_query(F.data == "repo:add")
async def repo_add_start(cb: CallbackQuery):
    await cb.message.answer("Формат: <alias> <url> [branch]\nПример: lovender https://github.com/user/repo main",
                            reply_markup=ForceReply(selective=True))
    await cb.answer()

@router.message(F.reply_to_message & F.reply_to_message.text.startswith("Формат:"))
async def repo_add_reply(message: Message):
    parts = (message.text or "").splitlines()[-1].split()
    if len(parts) < 2:
        return await message.answer("Нужно: <alias> <url> [branch]")
    alias, url, *rest = parts
    branch = rest[0] if rest else "main"
    async with session_scope() as st:
        await repo_add(st, message.from_user.id, alias, url, branch); await st.commit()
    await message.answer(f"Репозиторий добавлен: {alias} ({branch})")

@router.callback_query(F.data == "repo:list")
async def repo_list_open(cb: CallbackQuery):
    async with session_scope() as st:
        items = await repo_list(st, cb.from_user.id)
    if not items:
        return await cb.message.answer("Список пуст. Нажми ➕ Add.")
    rows = []
    for r in items:
        rows.append([
            InlineKeyboardButton(text=f"{r.alias} ({r.branch})", callback_data="noop"),
            InlineKeyboardButton(text="Sync", callback_data=f"repo:sync:{r.alias}"),
            InlineKeyboardButton(text="Remove", callback_data=f"repo:rm:{r.alias}"),
        ])
    await cb.message.answer("Репозитории:", reply_markup=InlineKeyboardMarkup(inline_keyboard=rows))
    await cb.answer()

@router.callback_query(F.data.startswith("repo:sync:"))
async def repo_sync_cb(cb: CallbackQuery):
    alias = cb.data.split(":")[-1]
    token = settings.github_token if hasattr(settings, "github_token") else None
    async with session_scope() as st:
        out = await repo_sync(st, cb.from_user.id, alias, token=token); await st.commit()
    await cb.message.answer(f"<code>{out[:3500]}</code>")
    await cb.answer()

@router.callback_query(F.data.startswith("repo:rm:"))
async def repo_rm_cb(cb: CallbackQuery):
    alias = cb.data.split(":")[-1]
    async with session_scope() as st:
        await repo_remove(st, cb.from_user.id, alias); await st.commit()
    await cb.message.answer(f"Удалён: {alias}"); await cb.answer()
```

---

# 6) Меню Actions: добавим Export / Repo / Cleanup

**`app/handlers/menu.py`** — в построитель меню добавь 2 рядка:

```diff
 rows = [
   [InlineKeyboardButton(text="📊 Статус", callback_data="status:show"),
    InlineKeyboardButton(text="🧹 Сброс фильтров", callback_data="ctx:reset")],
   [InlineKeyboardButton(text="📄 Импорт (последний файл)", callback_data="wizard:import"),
    InlineKeyboardButton(text="🗜️ Импорт ZIP — подсказка", callback_data="hint:importzip")],
   [InlineKeyboardButton(text="📚 Sources", callback_data="sources:toggle"),
    InlineKeyboardButton(text="🎯 Scope", callback_data="scope:toggle"),
    InlineKeyboardButton(text="🤫 Quiet", callback_data="quiet:toggle")],
   [InlineKeyboardButton(text="📂 Projects", callback_data="projects:list")],
+  [InlineKeyboardButton(text="📤 Export", callback_data="export:open"),
+   InlineKeyboardButton(text="🔗 Repo", callback_data="repo:open")],
+  [InlineKeyboardButton(text="🧹 Cleanup by date", callback_data="cleanup:open")],
 ]
```

И **подключи новые роутеры**:

**`app/handlers/__init__.py`**

```diff
 from .export import router as export_router
 from .repo import router as repo_router
 from .cleanup import router as cleanup_router
 router.include_router(export_router)
 router.include_router(repo_router)
 router.include_router(cleanup_router)
```

---

# 7) Projects — компактно + пагинация (если нужно)

Если проектов много — верни пагинацию (по 8 на страницу), как мы делали раньше. Иначе текущий список уже годен.

---

# 8) Пресеты тегов (+ свободный ввод)

**Миграция** `alembic/versions/0006_tag_presets.py`

```python
from alembic import op
import sqlalchemy as sa

revision = "0006_tag_presets"
down_revision = "0005_repos"

def upgrade():
    op.create_table("tag_presets",
        sa.Column("id", sa.Integer(), primary_key=True),
        sa.Column("user_id", sa.BigInteger(), nullable=False),
        sa.Column("project_id", sa.Integer(), nullable=True),
        sa.Column("tag", sa.String(64), nullable=False),
    )
    op.create_index("ix_tag_presets_user_proj", "tag_presets", ["user_id", "project_id"])

def downgrade():
    op.drop_index("ix_tag_presets_user_proj", table_name="tag_presets")
    op.drop_table("tag_presets")
```

**`app/services/tags.py`** (новый)

```python
from __future__ import annotations
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, delete, insert
from app.models import Project
from sqlalchemy import Table, Column, Integer, BigInteger, String, ForeignKey, MetaData

# быстрая табличка через Core (или добавь ORM-модель)
metadata = MetaData()
tag_presets = Table(
    "tag_presets", metadata,
    Column("id", Integer, primary_key=True),
    Column("user_id", BigInteger, nullable=False),
    Column("project_id", Integer, nullable=True),
    Column("tag", String(64), nullable=False),
)

DEFAULT_PRESETS = ["api","db","infra","matching","ui","auth","spec","plan","answer","summary","pinned","release-notes"]

async def get_presets(st: AsyncSession, user_id: int, project_id: int | None):
    res = await st.execute(select(tag_presets.c.tag).where(tag_presets.c.user_id==user_id, tag_presets.c.project_id==project_id))
    tags = [r[0] for r in res.fetchall()]
    return tags or DEFAULT_PRESETS

async def add_preset(st: AsyncSession, user_id: int, project_id: int | None, tag: str):
    await st.execute(insert(tag_presets).values(user_id=user_id, project_id=project_id, tag=tag.strip().lower()))

async def clear_presets(st: AsyncSession, user_id: int, project_id: int | None):
    await st.execute(delete(tag_presets).where(tag_presets.c.user_id==user_id, tag_presets.c.project_id==project_id))
```

**В `app/handlers/answer_actions.py`** заменим Tag-UX: сначала покажем клавиатуру пресетов (toggle), затем «Готово» + «Свои»:

```python
# вверху:
from app.services.tags import get_presets

def build_tag_kb(tags: list[str], msg_id: int):
    # 3 в ряд, плюс Done / Free input
    rows, row = [], []
    for i,t in enumerate(tags,1):
        row.append(InlineKeyboardButton(text=t, callback_data=f"ans:tagtoggle:{msg_id}:{t}"))
        if i%3==0: rows.append(row); row=[]
    if row: rows.append(row)
    rows.append([InlineKeyboardButton(text="✅ Готово", callback_data=f"ans:tagdone:{msg_id}"),
                 InlineKeyboardButton(text="✍️ Свои", callback_data=f"ans:tagfree:{msg_id}")])
    return InlineKeyboardMarkup(inline_keyboard=rows)

# текущее выбранное множество держим в памяти на 2 минуты (простая мапа)
TAG_CACHE: dict[int, set[str]] = {}

@router.callback_query(F.data.startswith("ans:tag:"))
async def ans_tag(cb: CallbackQuery):
    msg_id = int(cb.data.split(":")[-1])
    async with session_scope() as st:
        # project-specific пресеты
        bm = (await st.execute(sa.select(BotMessage).where(BotMessage.tg_message_id==msg_id))).scalars().first()
        pid = bm.project_id if bm else None
        presets = await get_presets(st, cb.from_user.id, pid)
    TAG_CACHE[msg_id] = set()
    await cb.message.answer("Выбери теги (тап по кнопкам), потом нажми «Готово».",
                            reply_markup=build_tag_kb(presets, msg_id))
    await cb.answer()

@router.callback_query(F.data.startswith("ans:tagtoggle:"))
async def ans_tag_toggle(cb: CallbackQuery):
    _, _, msg_id, tag = cb.data.split(":")
    msg_id = int(msg_id)
    cur = TAG_CACHE.get(msg_id, set())
    if tag in cur: cur.remove(tag)
    else: cur.add(tag)
    TAG_CACHE[msg_id] = cur
    await cb.answer(f"{'+' if tag in cur else '-'} {tag}")

@router.callback_query(F.data.startswith("ans:tagdone:"))
async def ans_tag_done(cb: CallbackQuery):
    msg_id = int(cb.data.split(":")[-1])
    tags = sorted(TAG_CACHE.get(msg_id, set()))
    if not tags:
        return await cb.answer("Не выбрано ни одного тега.", show_alert=True)
    # применим как раньше, только без ForceReply
    async with session_scope() as st:
        bm = (await st.execute(sa.select(BotMessage).where(BotMessage.tg_message_id==msg_id))).scalars().first()
        if not bm: return await cb.answer("Not found", show_alert=True)
        text = cb.message.text or cb.message.caption or ""
        target_pid = bm.project_id
        if not bm.saved or not bm.artifact_id:
            if not target_pid:
                return await cb.message.answer("Сначала выбери проект в Actions → Projects.")
            base = Artifact(project_id=target_pid, kind="answer", title="Chat answer", raw_text=text, pinned=False)
            st.add(base); await st.flush()
            bm.artifact_id = base.id; bm.saved = True; st.add(bm)
        await st.execute(sa.delete(artifact_tags).where(artifact_tags.c.artifact_id == bm.artifact_id))
        await st.execute(sa.insert(artifact_tags), [{"artifact_id": bm.artifact_id, "tag": t} for t in tags])
        await st.commit()
    await cb.message.answer(f"🏷 Теги: {', '.join(tags)}")
    TAG_CACHE.pop(msg_id, None)
    await cb.answer()

@router.callback_query(F.data.startswith("ans:tagfree:"))
async def ans_tag_free(cb: CallbackQuery):
    msg_id = int(cb.data.split(":")[-1])
    await cb.message.answer("Свои теги (через запятую):", reply_markup=ForceReply(selective=True))
    await cb.answer()

@router.message(F.reply_to_message & F.reply_to_message.text.startswith("Свои теги"))
async def tags_free_reply(message: Message):
    tags = [t.strip() for t in (message.text or "").split(",") if t.strip()]
    if not tags: return await message.answer("Пусто.")
    # Применим к последнему BotMessage пользователя, аналогично предыдущему коду
    async with session_scope() as st:
        bm = (await st.execute(sa.select(BotMessage).where(BotMessage.user_id==message.from_user.id)
              .order_by(BotMessage.created_at.desc()).limit(1))).scalars().first()
        if not bm: return await message.answer("Не нашёл сообщение для тегов.")
        text = message.reply_to_message and (message.reply_to_message.text or "") or ""
        target_pid = bm.project_id
        if not bm.saved or not bm.artifact_id:
            if not target_pid: return await message.answer("Сначала выбери проект.")
            base = Artifact(project_id=target_pid, kind="answer", title="Chat answer", raw_text=text, pinned=False)
            st.add(base); await st.flush()
            bm.artifact_id = base.id; bm.saved = True; st.add(bm)
        await st.execute(sa.delete(artifact_tags).where(artifact_tags.c.artifact_id == bm.artifact_id))
        await st.execute(sa.insert(artifact_tags), [{"artifact_id": bm.artifact_id, "tag": t} for t in tags])
        await st.commit()
    await message.answer(f"🏷 Теги: {', '.join(tags)}")
```

> Позже можно добавить «/tags preset Lovender: …», чтобы заранее забить пресеты на проект — база уже есть.

---

# 9) Scope-плашка — уже добавили в прошлой итерации (кнопки `auto / project / global`).

---

## Как проверить (чек-лист)

1. `docker compose run --rm bot alembic upgrade head` → применятся `0005_repos` и `0006_tag_presets`.
2. `linkbot-reset.ps1 -Rebuild` (или просто `linkbot`).
3. **Actions**:

   * **📤 Export** → показывает активный проект в кнопке, экспортит zip.
   * **🔗 Repo** → Add/List/Sync/Remove работают; Sync показывает лог `git`.
   * **🧹 Cleanup by date** → вводишь `2025-09-13`, удаляет артефакты с этой даты и новее (в активном проекте).
4. Импорт txt/zip → автоматически добавляется тег `rel-YYYY-MM-DD`; .pmignore фильтрует мусор.
5. **Tags** → «🏷 Tag» открывает плашку пресетов; можно выбрать/снять → «Готово» применяет. «✍️ Свои» — ручной ввод.
